---
title: "TP Multi-omics"
author: "Goulancourt Rebecca & Jamay Théo"
date: "19/10/2021"
output: pdf_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

# Chargement des librairies

```{r}
BiocManager::install("mixOmics")
BiocManager::install("timeOmics")
install.packages("tidyverse")
```

```{r}
library("tidyverse")
library("mixOmics")
library("timeOmics")
```

# Chargement des données

```{r}
mirna <- read.csv("mirna.csv", sep  = ",", header = T, row.names = 1)
mrna <- read.csv("mrna.csv", sep = ",", header = T,row.names = 1)
protein <- read.csv("protein.csv", sep = ",", header = T, row.names = 1)
sample_group <- read.csv("sample_group.csv", sep = ",", header = T, row.names = 1)
```

# Partie I

# Question 1

```{r}
number_ech_miRNA <- nrow(mirna)
number_ech_mRNA <- nrow(mrna)
number_ech_protein <- nrow(protein)
```
Pour chaque variable il y a 150 échantillons

```{r}
variation_coef <- function(data_frame) {
  sd <- apply(data_frame, 2, sd)
  nu <- apply(data_frame, 2, mean)
  cv <- sd/nu
  
  hist(cv, main = "histogramme de la distribution du Cv",
       xlab = "coefficient de variation", ylab = "fréquence")
  
  return(cv)
}

liste <- list(mrna, mirna, protein)

for (df in liste) {
  var <- variation_coef(df)
  print(var)
}
```
variation_coef <- function(data_frame, name) {
  sd <- apply(data_frame, 2, sd)
  nu <- apply(data_frame, 2, mean)
  cv <- sd/nu
  
  hist(cv, main = "histogramme de la distribution du Cv", sub = paste("bloc_", name),
       xlab = "coefficient de variation", ylab = "fréquence")
  
  return(cv)
}

liste <- list(mrna = mrna, mirna = mirna, protein = protein)

for (i in liste) {
  n <- names(liste)[i]
  var <- variation_coef(i, n)
  print(var)
}


# Question 2

La distribution du coefficient de variation n'est pas similaire dans chacun des blocs
l'histogramme possédant le plus de variabilité est l'histogramme de la df protein car l'axe des abscisses est bien plus étendu que pour les autres histogrammes ([-100,200])


new_liste <- list()
for (i in 1:length(liste)) {
  var <- variation_coef(liste[i])
  cor_cv <- liste[i][,abs(var) >= 0.15]
  new_liste[i] <- cor_cv

}


```{r}
liste_var <- NULL
for (i in liste) {
  var <- variation_coef(i)
  cor_cv <- var[abs(var) >= 0.15]
  print(cor_cv)
  liste_var <- c(liste_var, list(cor_cv))
}
```

# Question 3

```{r}
for (i in liste_var) {
  print(length(i))
}
```

# Question 4

df_mrna <- as.data.frame(liste_var[1])
df_mirna <- as.data.frame(liste_var[2])
df_prot <- as.data.frame(liste_var[3])

max_liste <- NULL

for (i in liste_var) {
  #print(summary(i))
  max_liste <- cbind(max_liste, max(i))
  gene <- which(i == max(i))
  print(gene)
  #print(gene %in% i)
  #if (gene %in% i) {
  #if (match(gene, i) == TRUE) {
  #  print(gene, "est présent")
  #}
} 
print(max_liste)

  for (j in rownames(df_mrna)) {
    print(j[gene])
    #name_gene <-  
    
    
name_gene <- df_mrna[gene,]
print(name_gene)
name_gene <- list(rownames(df_mrna))
print(name_gene)
print(typeof(name_gene))
name_gene[160]
print(typeof(df_mrna))
print(row(df_mrna[gene,]))
print(name_gene[gene])
```{r}
df_mrna <- as.data.frame(liste_var[1])
df_mirna <- as.data.frame(liste_var[2])
df_prot <- as.data.frame(liste_var[3])

for (i in df_mrna) {
  gene <- which(i == max(i))
  print(gene)
}

for (i in 1:gene) {
  name <- rownames(df_mrna)[i]
}

print(paste0("le gène le plus variant est le ", name, " avec un maximum de Cv de ", max(i)))
```
```{r}
print(match(name, rownames(df_mrna)))
rownames(df_mrna)[name] %in% colnames(protein)
```
pas présent dans le jeu de données protéique car FALSE

# Question 5

On cherche PLCD4 humaine sur Uniprot -->
role = Hydrolyzes the phosphatidylinositol 4,5-bisphosphate (PIP2) to generate 2 second messenger molecules diacylglycerol (DAG) and inositol 1,4,5-trisphosphate (IP3). DAG mediates the activation of protein kinase C (PKC), while IP3 releases Ca2+ from intracellular stores. Required for acrosome reaction in sperm during fertilization, probably by acting as an important enzyme for intracellular Ca2+ mobilization in the zona pellucida-induced acrosome reaction. May play a role in cell growth. Modulates the liver regeneration in cooperation with nuclear PKC. Overexpression up-regulates the Erk signaling pathway and proliferation.
+ activité catalytique

localisation chromosomique = chromosome 2

longueur = inconnu?
longueur = 762 acides aminés


# Partie 2

# Question 6

ACP = Analyse en composante principale est une méthode d'analyse multidimensionnelle (sur des variables quantitatives uniquement) et permet d'observer le comportement de variables à n dimensions en les réduisants à 2 dimensions tout en gardant le maximum d'informations possible.
Cela permet d'étudier la corrélation entre des variables et la création potentielle de groupes homogènes.

```{r}
install.packages("FactoMineR")
install.packages("factoextra")
library("FactoMineR")
library("factoextra")
```

```{r}
#tune.pca(mrna, ncomp = 10, center = TRUE, scale = FALSE)
#acp <- PCA(mrna, scale.unit = TRUE, ncp = 2)
acp <- pca(mrna, ncomp = 10, center = TRUE, scale = TRUE)
plot(acp)
```
# Question 7 

On retiens 2 composantes car ils expliquent le mieux la variance

```{r}
acp <- pca(mrna, ncomp = 2, center = TRUE, scale = TRUE)
plotVar(acp, comp = c(1, 2), var.names = TRUE, 
        title = 'ACP des variables de mRNA')
```


# Question 8

variables qui contribuent le + à l'axe 1 (on prends arbitrairement les variables dont la contribution est > 1) :


var_1 <- NULL
for (i in contrib[, "Dim.1"]) {
  if (i > 1) {
    print(rownames(contrib)[i])
    var_1 <- cbind(var_1, rownames(contrib)[i])
  }
}

```{r}
var <- get_pca_var(acp)
contrib <- as.data.frame(var$contrib)

var_1 <- NULL
for (i in 1:nrow(contrib)) {
  if (contrib[i, "Dim.1"] > 1) {
    #print(rownames(contrib)[i])
    var_1 <- cbind(var_1, rownames(contrib)[i])
  }
}

print("Variables contribuant le plus à l'axe 1 :   ")
print(var_1)
```
df_var <- NULL
for (i in rownames(contrib)) {
  print(i)
    for (j in var_1) {
      if (i == j) {
        df_var <- cbind(df_var, contrib[i])
      }
    }
}

for (i in 1:nrow(contrib)) {
  #print(contrib[i,])
  #print(rownames(contrib[i,]))
  for (j in var_1) {
    if (j == rownames(contrib)[i]) {
      df_var <- cbind(df_var, contrib[i,])
    }
  }
}

for (i in lines) {
  #print(i)
  print(contrib[i,])
  df_var[i,] <- rbind(df_var, contrib[i,])
}

```{r}
df_var <- NULL
lines <- c(match(var_1, rownames(contrib)))
      
for (i in lines) {
  #print(i)
  #print(contrib[i,])
  df_var <- rbind(df_var, contrib[i,])
}

#acp_var <- PCA(df_var, scale.unit = TRUE, ncp = 2)
#title("ACP des variables contribuant le plus à l'axe 1")

```

```{r}
acp2 <- pca(mrna, ncomp = 2, center = TRUE, scale = TRUE)
plotIndiv(acp2, comp = c(1, 2), ind.names = TRUE, 
          group = sample_group$Y, style = 'ggplot2',
          legend = TRUE, title = 'ACP des échantillons')
```
pas bcp d'infos --> seulement 12+22 = 34% de la variance expliquée

```{r}
spca <- spca(mrna, ncomp = 2, center = TRUE, scale = TRUE, keepX = c(10, 5))
plot(spca, xlim = c(-15, 15), ylim = c(-15, 15))
```






